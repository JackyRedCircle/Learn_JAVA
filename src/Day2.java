//import java.util.*; //Scanner 임포트

public class Day2 {
    public static void main(String[] args) {
//        Scanner scanner = new Scanner(System.in);//Scanner 객체 생성

//        int num = scanner.nextInt();// 정수 값을 받아와 num에 저장
//        System.out.println(num);//num 값 출력

//        String input = scanner.nextLine();//행단위로 입력받아 input에 저장
//        int num1 = Integer.parseInt(input); //문자열로 받은 수 input을 정수형 num에 저장, 문자열 -> 정수(숫자)
////        위 두 줄(10,11행)을 합친 것이 7번행임.
//        System.out.println(num1);//정수형 num값 출력
//        -------------Scanner 실습

//        타입간의 변환방법
//        String str = "3";
//        char ch = '2';
//        int i = 1;
//
//        System.out.println(str.charAt(0)-'0'); //문자열(string)3을 문자(char)3으로 변환 ("3" -> '3')후, 문자3을 정수(int)3으로 변환 ('3' -> 3)
//        System.out.println(Integer.parseInt("3")+1); //문자열3을 정수3으로 변환 후 1을 더함
//        System.out.println(ch + ""); //""을 더함으로써 문자2를 문자2로 변환 ('2' -> 2)
//        System.out.println((char)(i + '0')); //정수i에 문자0을 더한 후 형변환을 통해 문자1로 변환 (1 -> '1')
//        -------------------타입간의 변환

//        연산자와 피연산자

//        x + 3 에서 연산자는 "+", 피연산자는 x와 3. 또한 모든 연산자는 연산결과를 반환한다.
//        연산자의 종류: 산술, 비교, 논리, 대입, 기타 연산자가 있다.\
//        산술연산자: + - * / % << >> (덧셈, 뺄셈, 곱셈, 나눗셈, 나머지, 비트연산자)
//        비교연산자: > < >= <= == != (큰가?, 작은가?, 이상인가?, 이하인가?, 같은가?, 다른가?)
//        논리연산자: && || ! & | ^ ~ (그리고, 또는, ~가 아닌, )
//        대입연산자: =
//        기타: (type) ?: instanceof (형변환, 3항연산자, )
//        ------------------

//        연산자의 우선순위

//        "()" > "*" = "/" > "+" = "-" >>>>>>>>>>>>>>> "=" (대입연산자는 최하위우선순위임.)
//        ----   ----------------------
//        수동            자동

//        case1) -x + 3
//                  단항연산자가 이항연산자보다 우선순이가 높음. -는 부호연산자.
//        case2) x + 3 > y - 2
//                  비교연산자가산술연산자보다 우선순위가 낮음. 따라서 'x+3', 'y-2'실행 후 비교.
//        case3) x > 3 && y < 5
//                  논리연산자가 비교연산자보다 우선순위가 낮음. 따라서 'x>3', 'y<5' 비교 후, &&연산.
//        tip. 상식적으로 생각하면 외울 필요 없음.
//        * 대입 및 단항 연산 이외에는 전부 우선순위가 동일한 연산자끼리는 왼쪽에서 오른쪽(상식적인 순서)로 진행.
//              ex) x + y + z               X = Y = 3
//                  --------->              <--------    (연산순서)

//        ----------------------------------------

//        증감연산자 ++ --

//        증가연산자: ++ 1을 증가시킨다.
//        감소연산자: -- 1을 감소시킨다.

//        전위형: 값이 참조되기 전, 1 증가  ex) j = ++i;    -> i + 1 후 j = i
//        후위형: 값이 참조된 후, 1 증가   ex) j = i++;     -> j = i 후 i + 1
//        * 단, 증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형은 차이가 없음. 즉, i++ = ++i.

//        int n=5, j=0;
//
//        j=n++; //후위형
//        System.out.printf("n=5, j=0 일때,%nj=n++ 실행 후, n=%d, j=%d %n",n,j);
//
//        j=0;
//        n=5;
//
//        j=++n;
//        System.out.printf("j=++n 실행 후, n=%d, j=%d %n",n,j);
//        -----------------------

//        부호연산자
//        * 단항연산자임(피연산자가 1개라는 뜻)
//        * +부호연산자가 있긴하나, 아무일도 하지 않음. (상식선에서 이해)

//        형변환 연산자
//        * 형변환: 변수 또는 상수의 타입을 다른 타입으로 변환(형변환)하는 것.

//        문법: (변환하고싶은 타입)피연산자
//        ex) double d = 85.4;
//            int score = (int)d;    -> 실수타입 d를 정수형으로 변환한 후 score에 저장.
//        * 이때, 실수형을 정수형으로 변환하면 소숫점 이하는 버림.(반올림X)
//        * 정수형을 실수형으로 변환하면 정수 뒤에 .0이 붙음.

//        자동형변환
//        * ex) float f = 1234;   -> 분명 대입연산자 기준으로 양측의 자료형이 다르나, 정수형을 실수형으로 자동 형변환 후 저장.
//        자동형변환 기준: 대입연산자 기준 좌측의 타입이 우측의 타입보다 범위가 넓을 경우만 가능. 다른말로, 과정 중 값손실이 생기면 불가능.
//        "값손실이 적은쪽으로 변환"

//        산술변환
//        ex) long + int -> long
//            float + int -> float
//            double + float -> double
//        * int보다 작은 타입은 int로 변환 후 계산
//        ex) byte + short = int
//        * 타입 변환 중 (문자 -> 정수)의 원리
//        ex) '2' - '0' -> (각 문자를 유니코드로 변환) 50 - 48 = 2
//        결론은 '2' -> 2
//        * int로 변환하는 이유는? -> integer보다 작은 자료형의 경우, 결과값이 범위를 넘기가 쉬워 이를 해결하고자 integer로 변환.

//        * 만약 integer이상의 자료형에서 결과값이 범위를 넘어(오버플로우)간다면?
//        -> 계산 전 하나 이상의 변수나 상수를 형변환 해준 후 계산.

//        반올림 - Math.round()메서드
//        * 소숫점 첫 째자리에서 반올림한 정수를 반환
//        long result = Math.round(3.14);
//        System.out.println(result); -> 결과값은 3 (1에서 반올림)
//        * n쨰자리까지 반올림하려면? -> 해당 값을 10^n으로 곱한후 반올림 하고 다시 10^n으로 나눔
//        ex) double X = 3.141592
//            double Y = X * 10000 // 소수 4째자리까지 반올림을 위해 10^4을 곱함
//            Math.round(Y); // Y값 반올림
//            double Z = Y/10000; // 값의 원상복귀를 위해 Y를 10000으로 나눈 후 Z에 저장

//        * n째자리까지 버리려면? -> 10^n을 곱한 후 정수형 자료형으로 형변환을 통해 값손실을 낸 후 다시 10^n으로 나눔

//        나머지연산자 %
//        * ex) 10 % 8 = 2
//        * 단, 피연산자로는 정수만 가능하고, 부호는 무시됨. 즉, 10%8 = 10%-8 = 2

//        문자열의 비교
//        * ==을 사용해도 되나, 항상 올바른 결과를 도출하지 못하므로 왠만하면 equals()를 사용한다.
//        * 문법: A.equals(B); // 문자열A와 문자열B가 같은지 비교
//        ex)
//     case1) String str1 = "abc";
//            String str2 = "abc";

//            System.out.println(str1==str2); // true
//            System.out.println(str1.equals.(str2)); // ture
//-----------------------------------------------------------------
//     case2) String str1 = new String("abc");
//            String str2 = new String("abc");

//            System.out.println(str1==str2); // false
//            System.out.println(str1.equals.(str2)); // ture

//        "문자 ch는 숫자이다"를 코드로?
//        * '0' < ch && ch < '9';
//        -> 다음과 같은 코드가 성립 할 수 있는 이유는 유니코드 0~9가 연속적으로 배치되어있어 가능.

//        "문자 ch는 대문자 또는 소문자 이다"는?
//        * ('a' < ch && ch < z') || ('A' < ch && ch < 'Z');
//        -> 이 또한 영문 a~z와 A~Z의 유니코드가 연속적으로 배치되어있어 가능.

//        조건연산자 ?:
//        * 조건식의 결과에 따라 연산결과를 달리한다.
//        문법: 조건식 ?: 식1 : 식2
//        ex) result = (x>y) ?: x : y;  (괄호는 안 넣어도 됨)
//        -> x>y이면 x실행. 아니면 y실행
//        * if문을 간단히 한 형태.

//        복합대입연산자
//        * 대입연산자와 다른 연산자를 하나로 축약
//        ex) i = i + 3   ->    i += 3
    }
}
